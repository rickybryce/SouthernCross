; Binary / Hex Flash Card Program
; AFTER RUNNING, ENTER THE CORRECT HEX VALUE FOR
; THE DISPLAYED BINARY PATTERN.
;     + WILL DISPLAY TOTAL CORRECT ANSWERS
;     - WILL DISPLAY TOTAL INCORRECT ANSWERS
;     ANSWERS ROLLOVER TO ZERO PAST 99

; V 1.0 -- USING WILLIAM COLLEY'S AZ80 ASSEMBLER (LINUX)
; https://www.retrotechnology.com/restore/az80.html
; ASSEMBLER HAS .EXE FOR WINDOWS...
; TO COMPILE AZ80 ASSEMBLER IN LINUX:
    ; ln -s az80.H AZ80.h  (or vice versa)
    ; gcc -I. -o az80 z80.c z80util.c az80eval.c
    ; chmod +x az80 ; allow execution
; -- RICKY BRYCE

; TO SET BAUD RATE IN LINUX FOR FIRST SERIAL DEVICE:
; stty -F /dev/ttyUSB0 ispeed 4800
; (ON MINE, I NEED TO DO THIS TWICE FOR SOME REASON)

; TO ASSEMBLE, CREATE INTEL HEX FILE, AND UPLOAD ALL AT ONCE, 
; CREATE EXECUTABLE SHELL CALLED assemble:
; stty -F /dev/USB0 ispeed 4800 ; we get an error for some reason
; stty -F /dev/USB0 ispeed 4800 ; so set it again -- 2nd time 
                                ; there is no error.
                                
; stty -F /dev/USB0  ; show baud rate setting (should be 4800)
;  ./az80 $1.z80 -l $1.lst -o $1.hex
;  sleep 1
;  cat $1.hex > /dev/ttyUSB0
;  echo "Done..."

; AFTER SAVING THE FILE, MAKE IT EXECUTABLE chmod +x assemble
; TO ASSEMBLE, AND TRANSMIT FILE, TYPE: ./assemble filename
; Z80 EXTENSION IS ASSUEMED AND NAME IS PASSED TO SHELL FILE AS $1

    ORG $2000       ; START PROGRAM AT $2000

; ** BEGIN INTRO **
INTRO:
    LD B,$FF        ; START B AT $FF
    LD HL,$0002     ; TONE DURATION
INTLOOP:
    LD A,$3F        ; SET A FOR 6 DISPLAYS AT ONCE
    OUT ($85),A     ; THEN TURN THEM ON
    LD A,B          ; LOAD LOOP VALUE TO A
    OUT ($84),A     ; SEND THIS TO THE DISPLAYS
    LD C,TONE       ; THEN SOUND A TONE FOR THIS VALUE
    RST SYSTEM
    DJNZ INTLOOP
    
; ** BEGIN INITIALIZE **
INIT:    
    LD A,0 ; ACCUMULATOR
    LD DE,0 ; USING D FOR KEYPRESSES
    LD HL,0 ; 16 BIT REGISTER (FOR MEMORY ADDRESSES)
    LD BC,0 ; USED TO DETERMINE NEXT ANSWER, AND FOR LOOPING
    LD (CORRECT),A
    LD (INCORRECT),A
    LD (ANSWER),A
    LD C,CLRBUF          ; CLEAR DISPLAY BUFFER
    RST SYSTEM          ; SYSTEM CALL
    OUT ($85),A
    OUT ($84),A
; ** END INITIALIZE **
    
; ** END INTRO **

; ** WAIT FOR KEYPRESS **   
BEGIN:
    LD A,$0F             ; START A AT MAX POSSIBLE ANSWER
RTIME:
    LD B,A  ; B HOLDS THE NEXT QUESTION (B CREATES A "RANDOM" VALUE)
    CALL QDISPLAY       ; DISPLAY THE QUESTION
    IN A,($86)          ; GET THE ANSWER FROM USER (KEYPAD PORT)
    BIT 5,A             ; CHECK KEYPAD STATUS BIT
    JR NZ,KEYPRESS      ; IF KEY IS PRESSED, THEN GO CHECK IT.
    LD A,B              ; RELOAD A FROM B
    DEC A               ; DEC A     

    JR NZ,RTIME         ; IF A !=0, THEN LOOP 
    LD A,$0F            ; IF A = 0 THEN RESET A TO $0F
    JR RTIME            ; LOOP
    
KEYPRESS:
    AND $1F             ; MASK OUT UPPER NYBBLE
    LD D,A              ; LOAD D WITH KEYPRESS VALUE
    PUSH AF             ; BACKUP AF
    LD A,$12            ; LOAD A WITH "PLUS" VALUE
    CP D                ; SEE IF D IS $12 (+)
    JR Z,NUMCORR        ; DISPLAY NUMBER CORRECT
    LD A,$13            ; LOAD A WITH "MINUS" VALUE
    CP D                ; CHECK IF D IS $13 (-)
    JR Z,NUMINCORR      ; DISPLAY NUMBER INCORRECT
    POP AF              ; RESTORE AF
    LD D,A              ; D AGAIN HAS KEY VALUE
    LD HL,ANSWER        ; LOAD HL WITH ADDRESS OF ANSWER
    LD A,(HL)           ; LOAD ANSWER TO A
    CP D                ; COMPARE ANSWER TO KEYPRESS
    JR NZ,WRONG         ; IF IT DOES NOT MATCH, JUMP TO "WRONG" LABEL
    JR RIGHT            ; OTHERWISE, JUMP TO RIGHT LABEL

NUMCORR:                ; BACKUP BC TO STACK
    LD A,(CORRECT)      ; LOAD A WITH # CORRECT ANSWERS
    JR DBYTE            ; DISPLAY RESULT

NUMINCORR:              ; BACKUP BC TO STACK
    LD A,(INCORRECT)    ; LOAD A WITH # INCORRECT ANSWERS
    JR DBYTE            ; DISPLAY RESULT

DBYTE:
    LD C,DISBYT         ; SEND A TO STARBOARD DISPLAY
    RST SYSTEM         ; CALL SYSTEM
    LD C,SKEYRL         ; WAIT FOR KEY RELEASE
    RST SYSTEM         ; SYSTEM CALL
    LD C,CLRBUF         ; CLEAR DISPLAY BUFFER
    RST SYSTEM         ; SYSTEM CALL
    JP BEGIN            ; RESTART
    
WRONG:

    LD A,(INCORRECT)   ; STORE A TO MEMORY  
    INC A              ; INCREMENT A
    CALL FIXA          ; TEST FOR HEX CHARS
    LD (INCORRECT),A   ; STORE INCREMENTED VALUE TO MEMORY
    CALL BADTONE
    LD C,SKEYRL         ; WAIT UNTIL KEY RELEASE
    RST SYSTEM          ; SYSTEM CALL
    JP BEGIN            ; TRY AGAIN
    
RIGHT:
    LD A,(CORRECT)      ; LOAD A FROM MEMORY    
    INC A               ; INCREMENT A
    CALL FIXA           ; CHECK FOR HEX CHARS
    LD (CORRECT),A      ; STORE A TO MEMORY
    CALL GOODTONE
    LD C,SKEYRL         ; WAIT UNTIL KEY RELEASE
    RST SYSTEM
    LD HL,ANSWER        ; LOAD HL WITH ADDRESS OF ANSWER
    LD (HL),B           ; LOAD NEW VALUE INTO ANSWER
    JP BEGIN            ; RE-RUN
    
FIXA: 
    LD E,A              ; BACKUP A TO E
    AND $0F             ; MASK OUT UPPER NYBBLE
    CP $0A              ; CHECK IF LOWER NYBBLE REACHED $0A
    JR Z,ADD6           ; IF SO, THEN JUMP TO ADD6
    LD A,E              ; RESTORE A 
    RET
ADD6:
    LD A,E              ; RESTORE ORIGINAL VALUE OF A
    ADD A,$06           ; ADD 6
    LD E,A              ; BACKUP NEW VALUE TO E
    AND $F0             ; MASK OUT LOWER BITS
    CP $A0              ; SEE IF WE'VE REACHED $A0
    JR Z,ROLLOVER       ; IF SO, THEN ROLLOVER TO ZERO  
    LD A,E              ; IF NOT RESTORE A AND RETURN
    RET
ROLLOVER:
    LD A,0              ; ROLL A OVER TO 0
    RET

GOODTONE:
    PUSH HL
    PUSH BC
    PUSH AF
    LD HL,$0025         ; TONE DURATION
    LD A,$25
    LD C,TONE           ; PLAY TONE
    RST SYSTEM          ; SYSTEM CALL
    LD A,$15
    LD C,TONE
    RST SYSTEM         ; SYSTEM CALL
    POP AF
    POP BC
    POP HL
    RET
    
    
BADTONE:
    PUSH HL
    PUSH BC
    PUSH AF
    LD HL,$0025         ; TONE DURATION
    LD A,$55
    LD C,TONE           ; PLAY TONE
    RST SYSTEM          ; SYSTEM CALL
    LD A,$75
    LD C,TONE
    RST SYSTEM         ; SYSTEM CALL
    POP AF
    POP BC
    POP HL
    RET

    
    
QDISPLAY:
    LD A,(ANSWER)       ; LOAD ANSWER TO A
    OR A                ; CHECK IF ZERO SAME AS CP 0
    LD HL,(BVALUES)     ; IF SO, LOAD BVALUES ($0000)
    JR Z, DISPLAYQ      ; CALL DISPLAYQ
    LD HL,BVALUES
    
    PUSH BC             ; STORE BC TO STACK
    LD B,A              ; LOAD B FROM A
QUESTIONLOOP:
    INC L   ; INCREMENT L TWICE TO ADVANCE THROUGH BVALUES
    INC L
    DJNZ QUESTIONLOOP   ; DECREMENT B AND JUMP, LOOP UNTIL ZERO
    POP BC              ; RESTORE BC

    LD A,(HL)  ; LOAD LOW BYTE TO ACCUMULATOR
    INC L      ; INCREMENT HL
    LD H,(HL)  ; LOAD HIGH BYTE TO H
    LD L,A     ; LOAD LOW BYTE FROM A BACK TO L
    

DISPLAYQ:
    LD C,DISADD ; ADD HL TO DISPLAY BUFFER.  CONVERT TO DISPLAY
    RST SYSTEM  ; SYSTEM CALL
    LD C,SCAND  ; SCAN DISPLAY
    RST SYSTEM  ; SYSTEM CALL
    RET
    
    
    ORG $2200
;  ** DEFINE BYTES **
BVALUES:  
    DB $00,$00,$01,$00,$10,$00,$11,$00
    DB $00,$01,$01,$01,$10,$01,$11,$01
    DB $00,$10,$01,$10,$10,$10,$11,$10
    DB $00,$11,$01,$11,$10,$11,$11,$11
ANSWER:
    DB $00
CORRECT:
    DB $00
INCORRECT:
    DB $00


    
; ** END DEFINE BYTES
; CREATE LABEL (ALIAS) NAMED SYSTEM FOR MONITOR ENTRY POINT
SYSTEM: EQU $30
BREAK:  EQU $38
   
; Pasted some code out of the monitor definitions file.
; This is not the whole file.
; to obtain the file, visit:
; https://github.com/crsjones/Southern-Cross-Computer-z80/tree/main/SouthernCrossSBC_Monitor/SCMonitorV18
;--------------------------------------------
; S O U T H E R N   C R O S S   M O N I T O R
;--------------------------------------------
;
;  MONITOR DEFINITIONS FILE 
;  Version 1.8
;
; WRITTEN BY CRAIG R. S. JONES
; MELBOURNE, AUSTRALIA.
;
;--------------------
; SYSTEM CALL NUMBERS
;--------------------
;
;  LD   C,SYSTEM CALL NUMBER
;  RST  30H
;

MAIN:	EQU	0	;RESTART MONITOR
VERS:	EQU	1	;RETURNS MONITOR VERSION
DISADD:	EQU	2	;ADDRESS -> DISPLAY BUFFER
DISBYT:	EQU	3	;DATA -> DISPLAY BUFFER
CLRBUF:	EQU	4	;CLEAR DISPLAY BUFFER
SCAND:  EQU	5	;SCAN DISPLAY
CONBYT:	EQU	6	;BYTE -> DISPLAY CODE
CONVHI:	EQU	7	;HI NYBBLE -> DISPLAY CODE
CONVLO:	EQU	8	;LO NYBBLE - > DISPLAY CODE
SKEYIN:	EQU	9	;SCAN DISPLAY UNTIL KEY PRESS
SKEYRL:	EQU	10	;SCAN DISPLAY UNTIL KEY RELEASE
KEYIN:	EQU	11	;WAIT FOR KEY PRESS
KEYREL:	EQU	12	;WAIT FOR KEY RELEASE
MENU:	EQU	13	;SELECT ENTRY FROM MENU
CHKSUM:	EQU	14	;CALCULATE CHECKSUM
MUL16:	EQU	15	;16 BIT MULTIPLY
RAND:	EQU	16	;GENERATE RANDOM NUMBER
INDEXB:	EQU	17	;INDEX INTO BYTE TABLE
INDEXW:	EQU	18	;INDEX INTO WORD TABLE
MUSIC:	EQU	19	;PLAY MUSIC TABLE
TONE:	EQU	20	;PLAY A NOTE
BEEP:	EQU	21	;KEY ENTRY BEEP
SKATE:	EQU	22	;SCAN 8X8 DISPLAY
TXDATA:	EQU	23	;TRANSMIT SERIAL BYTE
RXDATA:	EQU	24	;RECEIVE SERIAL BYTE
ASCHEX:	EQU	25	;ASCII CODE -> HEX
WWATCH:	EQU	26	;WRITE TO SMART WATCH
RWATCH:	EQU	27	;READ FROM SMART WATCH
ONESEC:	EQU	28	;ONE SECOND DELAY USING SMARTWATCH
RLSTEP:	EQU	29	;RELAY SEQUENCER
DELONE:	EQU	30	;ONE SECOND DELAY LOOP
SCANKEY: EQU	31	;SCAN THE KEYBOARD
INTELH:	EQU	32	;RECEIVE INTEL HEX FILE
SPLIT:	EQU	33	;SEPARATE A BYTE INTO NYBBLES
SNDMSG:	EQU	34	;SND ZERO TERMINATED STRING TO SERIAL PORT
BITASC:	EQU	35	;CONVERT A BYTE INTO AN ASCII STRING OF ONES AND ZEROES
WRDASC:	EQU	36	;CONVERT A WORD TO ASCII
BYTASC:	EQU	37	;CONVERT A BYTE TO ASCII
NYBASC:	EQU	38	;CONVERT A NYBBLE TO ASCII
PCBTYP:	EQU	39	;RETURNS BOARD TYPE, SC OR TEC-1F
PRNTSZ:	EQU	40	;INLINE SERIAL PRINT STRING
KBDTYP:	EQU	41	;RETURNS KEYBOARD TYPE
UPDATE:	EQU	42  ;UPDATE DISPLAY AND MODE DECIMAL POINT SEGMENTS
VARRAM:	EQU	43	;RETURN BASE VARIABLE ADDRESS
SERINI:	EQU	44	;INITIALISE BIT BANG SERIAL PORT
SCBUG:	EQU	45	;SCBUG SERIAL MONITOR

;END OF INCLUDE FILE
    END

