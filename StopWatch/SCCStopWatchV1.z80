; STOPWATCH PROGRAM FOR SOUTHERN CROSS COMPUTER (Z80)
; V 3.0 -- USING Z80ASM ASSEMBLER (SLR SYSTEMS-1983)
; -- RICKY BRYCE


; TO SET BAUD RATE ON RC2014 (SERIAL B):
; SET CLOCK 2 TO .3072 --  4800 BAUD

; TO CREATE HEX, TYPE Z80ASM FILENAME/H
; EXTENSION .Z80 IS ASSUMED
; FULL LIST FILE: Z80ASM FILENAME/F

; TO TO TRANSMIT PRG TO SOUTHERN CROSS:
; USE QTERM (CTRL-Y THEN P)
; QTERM VERSION WILL TX/RX THROUGH SERIAL B

; BE SURE TO CROSSOVER TX/RX IN CABLE

    ORG 2000H
    
; DEFINE PRESETS FOR DELAY LOOP
; TO INCREMENT EVERY SECOND (TRIAL AND ERROR)

; ** BEGIN HEAD **
; THESE SETTINGS WILL COARSE ADJUST CLOCK CALIBRATION
; FOR FINER TUNING USE NOPS IN DELAY LOOP
DELAYLOW: EQU 03H	    ; DELAY LOW BYTE START 51H
DELAYHIGH: EQU 00H; 	; DELAY HIGH BYTE START 01H
; ** END HEAD **

; ** BEGIN INTRO **
INTRO:
    LD B,0FFH       ; START B AT $FF
    LD HL,0002H     ; TONE DURATION
INTLOOP:
    LD A,3FH        ; SET A FOR 6 DISPLAYS AT ONCE
    OUT (85H),A     ; THEN TURN THEM ON
    LD A,B          ; LOAD LOOP VALUE TO A
    OUT (84H),A     ; SEND THIS TO THE DISPLAYS
    LD C,TONE       ; THEN SOUND A TONE FOR THIS VALUE
    RST SYSTEM
    DJNZ INTLOOP
; ** END INTRO **

; ** BEGIN INITIALIZE **    
INIT: ; INITIALIZE REGISTERS AND MEMORY
    LD A,0  ; ZERO ACCUMULATOR
    LD DE,0 ; NOT USED HERE (CAN HOLD 16 BIT ADDRESSES)
    LD HL,0 ; 16 BIT REGISTER (FOR MEMORY ADDRESSES)
    LD BC,0 ; USED FOR DELAYS
    LD IX,SECOND ; IX AND IY ARE INDEX REGISTERS
    LD (IX+0),A ; FIRST DIGIT
    LD (IX+1),A ; SECOND DIGIT
    LD (IX+2),A ; THIRD DIGIT (NOT USED)
    LD (IX+3),A ; FOURTH DIGIT (NOT USED)
    LD (HUNDREDTH),A    ; ZERO HUNDREDTHS
    LD IX,DELAYTIME     ; IX AND IY ARE INDEX REGISTERS
    LD (IX+0),DELAYLOW  ; HIGH BYTE DELAY LOOP
    LD (IX+1),DELAYHIGH ; LOW BYTE DELAY LOOP

    LD C,CLRBUF		; CLRBUF CLEARS DISPLAY BUFFER (FUNCTION CODE $04)
    RST SYSTEM		; SYSCALL (MONITOR ENTRY POINT)
    LD HL,0000H		; SET UP TO DISPLAY 0
    LD C,DISADD		; CONVERT/ADD TO DISPLAY BUFFER
    RST SYSTEM		; CALL THE SYSTEM
    LD A,02H		; MODES: 1=RUN, 2=STOP, 3=RESET
    LD (WTMODE),A	; SAVE MODE 2 TO MEMORY
    LD A,00H		; LOAD A WITH 0H
    LD (RSTREQ),A	; BE SURE RESET REQUEST IS KILLED
; ** END INITIALIZE **    
   
; ** BEGIN MAIN ROUTINE **
BEGIN:

    CALL DELAY		; DELAY TO CALIBRATE FOR SECONDS

HUNDREDTHS:
    LD A,(HUNDREDTH)	 ; LOAD ACCUMULATOR WITH HUNDREDTHS
    INC A		         ; INCREMENT LOWER BYTE
    DAA                  ; ACCOUNT FOR DECIMAL
    LD (HUNDREDTH),A	 ; RESET HUNDREDTHS
    JP NZ,BEGIN          ; GO BACK TO BEGIN IF NO CARRY
    CCF
    
    CALL CLKTONE         ; SOUND TONE
    

FIRSTDIGIT:
    LD A,(SECOND)	     ; LOAD ACCUMULATOR WITH LOWER 
                         ; BYTE INTENDED FOR DISPLAY
    INC A		         ; INCREMENT LOWER BYTE
    DAA                  ; ACCOUNT FOR DECIMAL
    LD (SECOND),A	     ; RESET LOWER BYTE OF SECOND
    JP NZ,BEGIN          ; GO BACK TO BEGIN IF NO CARRY
    CCF


    
SECONDDIGIT:
    LD A,(SECOND+1)	     ; LOAD HIGH BYTE OF SECONDS SECOND TO ACCUMUATOR
    INC A		         ; INCREMENT THE ACCUMULATOR
    DAA                  ; ACCOUNT FOR DECIMAL
    LD (SECOND+1),A 	 ; STORE THE INCREMENTED VALUE BACK TO THE HIGH BYTE
    JP NZ,BEGIN          ; GO BACK TO BEGIN IF NOT ZERO
    CCF
    LD A,0		         ; LOAD 0 TO ACCUMULATOR
    LD (SECOND),A	     ; RESET LOW NYBBLE TO ZERO
    LD (SECOND+1),A	     ; RESET HIGH NYBBLE TO ZERO
    JP BEGIN		     ; RESTART
; ** END MAIN ROUTINE **

; ** BEGIN CHECK MDOE SUBROUTINE **
MODECHK:  ; MODE 1 = RUN; MODE 2 = STOP (HOLD) ; MODE 3 = RESET
MODE3:
    LD A,(WTMODE)	; LOAD MODE TO A
    CP 03H		    ; IF MODE IS 3, WE NEED TO RESET
    JP NZ,MODE2		; IF NOT 3 CHECK FOR MODE 2
    LD A,02H		; LOAD 02H TO THE ACCUMULATOR
    LD (WTMODE),A	; SET THE MODE TO HALT (02H)
    LD A,01H		; LOAD 01H TO ACCUMULATOR
    LD (RSTREQ),A	; NO REASON TO DELAY IF RESETTING
    LD A,00H		; LOAD 00H TO ACCUMULATOR
    LD (HUNDREDTH),A
    LD C,CLRBUF		; SET C TO CLEAR DISPLAY BUFFER
    RST SYSTEM		; SYSTEM CALL
    LD HL,0000H		; LOAD 0H BACK TO HL
    LD (SECOND),HL
    LD C,DISADD		; SEND THIS 0 TO DISPLAY BUFFER
    RST SYSTEM		; SYSTEM CALL
    ;JP MODERET		; RETURN FROM SUBROUTINE
MODE2:
    CALL CHECKKEY	; CHECK FOR KEYPAD INPUT
    CALL SCANDS		; SCAN THE DISPLAY
    LD A,(WTMODE)	; RELOAD A WITH MODE
    CP 02H		    ; IF MODE IS 2, WE NEED TO HOLD
    JP Z, MODE2		; HOLD IN LOOP
    JP MODERET		; IF MODE CHANGED, WE CAN RETURN

MODE1:			    ; IF MODE IS 1, WE DON'T NEED TO DO ANYTHING

MODERET:
    RET
; ** END CHECK MODE SUBROUTINE **
    
; ** BEGIN SCAN DISPLAY ROUTINE **    
SCANDS:			; SCAN THE DISPLAYS
    LD C,DISBYT
    LD A,(HUNDREDTH)
    RST SYSTEM
    LD C,DISADD		; DISADD CONVERT AND ADD TO DISPLAY BUFFER
    LD HL,(SECOND)	; DATA TO BE DISPLAYED (2 BYTES)
    RST SYSTEM		; SYSCALL (MONITOR ENTRY POINT)
    LD C,SCAND		; SCAN DISPLAY -- FUCNTION CODE $05
    RST SYSTEM		; SYSCALL (MONITOR ENTRY POINT)
    RET
; ** END SCAN DISPLAY ROUTINE **

; ** BEGIN CHECKKEY ROUTINE TO SEE IF A KEY IS PRESSED **
CHECKKEY:
    IN A,(86H)	    	; INPUT FROM KEYPAD AT PORT $86
    BIT 5,A             ; CHECK STATUS BIT OF KEYPAD
    JP NZ,CHECKKEYCNT1  ; IF KEY PRESSED JUMP OVER RETURN
    LD A,00H		    ; LOAD 0H TO ACCUMULATOR
    LD (KEYONS),A 	    ; CLEAR ONE SHOT BIT IF NO KEY PRESSED
    JP CHECKKEYRET      ; IF NO KEY PRESSED, THEN WE RETURN
CHECKKEYCNT1:
    ; AT THIS POINT, WE KNOW A KEY WAS PRESSED
    AND 1FH             ; GET RID OF THE UPPER 3 BITS
    LD (KEYVALUE),A     ; STORE THE KEY PRESSED TO KEYVALUE
    LD A,(KEYONS)	    ; LOAD A WITH ONE SHOT VALUE
    OR A                ; CHECK TO SEE IF IT'S CLEARED
    JP NZ,CHECKKEYRET   ; KEY IS STILL PRESSED FROM BEFORE
    LD A,(KEYVALUE)     ; RESTORE A WITH KEY VALUE
    CP 12H              ; CHECK FOR +
    JP NZ,NOT12H	    ; IF NOT 12H, CHECK FOR 13H
    CALL HIGHTONE       ; SOUND HIGH TONE
    LD A,01H		    ; LOAD 01H TO ACCUMULATOR
    LD (WTMODE),A	    ; SET MODE TO RUN
    LD (KEYONS),A	    ; SET ONE SHOT VALUE HIGH
    JP CHECKKEYRET      ; RETURN FROM SUBROUTINE
NOT12H:
    LD A,(KEYVALUE)     ; RELOAD KEY VALUE INTO A
    CP 13H              ; CHECK FOR -
    JP NZ,NOT13H	    ; IF NOT 13, CHECK FOR 0        
    CALL LOWTONE        ; SOUND LOW TONE
    LD A,02H		    ; LOAD 02H TO ACCUMULATOR
    LD (WTMODE),A  	    ; ENTER HOLD MODE
    LD A,01H		    ; LOAD 01H TO ACCUMULATOR
    LD (KEYONS),A	    ; SET ONE SHOT VALUE HIGH
    JP CHECKKEYRET      ; RETURN FROM SUBROUTINE
NOT13H:
    LD A,(KEYVALUE)	    ; RELOAD KEYVALUE MEMORY TO A
    OR A                ; COMPARE A TO 0
    JP NZ,NOKEY         ; KEY PRESSED IS INVALID
    LD A,03H		    ; LOAD 03H TO ACCUMULATOR MODE=3
    LD (WTMODE),A	    ; ENTER RESET MODE
    JP WAITKEYRL        ; TIMER PAUSES WHILE PRESSED
    
NOKEY:                  ; KEYPRESS IS INVALID
    RST BREAK           ; TROUBLESHOOTING
    JP CHECKKEYRET      ; RETURN FROM SUBROUTINE
    
WAITKEYRL:
    LD C, SKEYRL        ; WAIT FOR KEY RELEASE
    RST SYSTEM

CHECKKEYRET:
    RET     ; RETURN TO NEXT INSTRUCTION AFTER THIS CALL
; ** END CHECKKEY ROUTINE TO SEE IF A KEY IS PRESSED **

; ** BEGIN DELAY ROUTINE
DELAY:			; DELAY ROUTINE USING BC PAIR
    LD BC,(DELAYTIME)	; SET BC TO DELAYTIME
DELAY1:
    DEC BC		        ; DECREMENT BC PAIR
    LD A,00H		    ; LOAD ACCUMULATOR WITH ZERO
    LD (RSTREQ),A	    ; CLEAR KILLDELAY REQUEST
    PUSH BC		        ; BC USED BY SUBROUTINES -- BACK IT UP
    CALL CHECKKEY	    ; CHECK TO SEE IF A KEY IS PRESSED
    CALL MODECHK	    ; CHECK TIMER MODE
    CALL SCANDS   	    ; SCAN THE DISPLAYS

    POP BC		        ; RESTORE BC BEFORE GOING ANYWHERE ELSE
    LD A,(RSTREQ)  	    ; CHECK TO SEE IF WE NEED DELAY
    OR A              	; SEE IF IT'S OK TO CONTINUE DELAY
    JP Z, CONTDLY1    	; IF SO, CONTINUE
    JP DELAYRET       	; OTHERWISE, RETURN
CONTDLY1:
    LD A,B		; LOAD A WITH HIGH BYTE OF DLY SECOND
    OR C		; OR WITH C - CHECK FOR ANY HIGH BITS
    
    ; NOPS FOR TIME CALIBRATION
    NOP
    NOP 
    NOP
    NOP 
    NOP 
    NOP
    NOP 
    NOP
    NOP 
    NOP 
    NOP
    
    NOP 
    NOP
    NOP 
    NOP 
    NOP
    
    NOP   ; 1 SECOND / 18 MINUTES FAST
    NOP 
    NOP

    
    JP NZ,DELAY1	; RE-RUN LOOP
        

DELAYRET:
    RET ; ALL DONE WITH DELAY ROUTINE
; ** END DELAY ROUTINE **   

; ** BEGIN HIGH TONE **
HIGHTONE:
	LD HL,0075H	; TONE DURATION
	LD A,25H	; TONE PITCH
	LD C,TONE	; LOAD C WITH TONE FUNCTION CODE
	RST SYSTEM	; CALL SYSTEM
	LD A,15H	; TONE PITCH
	LD C,TONE	; LOAD C WITH TONE FUNCTION CODE
	RST SYSTEM	; CALL SYSTEM
	RET
; ** END HIGH TONE **

; ** BEGIN LOW TONE **
LOWTONE:
	LD HL,0025H	; TONE DURATION
	LD A,55H	; TONE PITCH
	LD C,TONE	; TONE FUNCTION CODE
	RST SYSTEM	; CALL SYSTEM
	LD A,75H	; TONE PITCH
	LD C,TONE	; TONE FUNCTION CODE
	RST SYSTEM	; CALL SYSTEM
	RET
; ** END LOW TONE **

; ** BEGIN CLICKTONE **
CLKTONE:    
	LD HL,0015H	; TONE DURATION
	LD A,99H	; TONE PITCH
	LD C,TONE	; TONE FUNCTION CODE
	RST SYSTEM	; CALL SYSTEM
	RET
; ** END CLICKTONE

; ** BEGIN FOOTER (DEFINE BYTES (DB)) **
    ORG 2300H		; AVOID CROSSING PAGE BOUNDARY
    
; ** BEGIN DATA TABLES (ARRAYS) **
DELAYTIME: 		; FOR DELAY LOOPS
    DB 0FFH,0FFH 	; THESE WILL BE OVERWRITTEN WITH 
				    ;CONSTANTS DEFINED IN HEADER
    
SECOND: ; DIGITS TO DISPLAY
    DB 00H,00H 	    ; THESE WILL BE OVERWRITTEN BY SECOND LOGIC 
                    ; (I'M ONLY USING THE FIRST TWO BYTES RIGHT NOW)
HUNDREDTH:
    DB 00H
                       
KEYVALUE:           ; STORE KEY VALUE
    DB 00H
WTMODE:			    ; MEMORY LOCATION FOR STOPWATCH MODE
    DB 00H
KEYONS:			    ; MEMORY LOCATION FOR ONE SHOT
    DB 00H
RSTREQ:			    ; MEMORY FLAG FOR RESET REQUEST
    DB 00H
; ** END DATA TABLES (ARRAYS) **  

; ** END FOOTER (DEFINE BYTES (DB)) **

; CREATE LABEL (ALIAS) NAMED SYSTEM FOR MONITOR ENTRY POINT
SYSTEM: EQU 30H
BREAK:  EQU 38H

   
; Pasted some code out of the monitor definitions file.
; This is not the whole file.
; to obtain the file, visit:
; https://github.com/crsjones/Southern-Cross-Computer-z80/tree/main/SouthernCrossSBC_Monitor/SCMonitorV18
;--------------------------------------------
; S O U T H E R N   C R O S S   M O N I T O R
;--------------------------------------------
;
;  MONITOR DEFINITIONS FILE 
;  Version 1.8
;
; WRITTEN BY CRAIG R. S. JONES
; MELBOURNE, AUSTRALIA.
;
;--------------------
; SYSTEM CALL NUMBERS
;--------------------
;
;  LD   C,SYSTEM CALL NUMBER
;  RST  30H
;

MAIN:	EQU	0	;RESTART MONITOR
VERS:	EQU	1	;RETURNS MONITOR VERSION
DISADD:	EQU	2	;ADDRESS -> DISPLAY BUFFER
DISBYT:	EQU	3	;DATA -> DISPLAY BUFFER
CLRBUF:	EQU	4	;CLEAR DISPLAY BUFFER
SCAND:  EQU	5	;SCAN DISPLAY
CONBYT:	EQU	6	;BYTE -> DISPLAY CODE
CONVHI:	EQU	7	;HI NYBBLE -> DISPLAY CODE
CONVLO:	EQU	8	;LO NYBBLE - > DISPLAY CODE
SKEYIN:	EQU	9	;SCAN DISPLAY UNTIL KEY PRESS
SKEYRL:	EQU	10	;SCAN DISPLAY UNTIL KEY RELEASE
KEYIN:	EQU	11	;WAIT FOR KEY PRESS
KEYREL:	EQU	12	;WAIT FOR KEY RELEASE
MENU:	EQU	13	;SELECT ENTRY FROM MENU
CHKSUM:	EQU	14	;CALCULATE CHECKSUM
MUL16:	EQU	15	;16 BIT MULTIPLY
RAND:	EQU	16	;GENERATE RANDOM NUMBER
INDEXB:	EQU	17	;INDEX INTO BYTE TABLE
INDEXW:	EQU	18	;INDEX INTO WORD TABLE
MUSIC:	EQU	19	;PLAY MUSIC TABLE
TONE:	EQU	20	;PLAY A NOTE
BEEP:	EQU	21	;KEY ENTRY BEEP
SKATE:	EQU	22	;SCAN 8X8 DISPLAY
TXDATA:	EQU	23	;TRANSMIT SERIAL BYTE
RXDATA:	EQU	24	;RECEIVE SERIAL BYTE
ASCHEX:	EQU	25	;ASCII CODE -> HEX
WWATCH:	EQU	26	;WRITE TO SMART WATCH
RWATCH:	EQU	27	;READ FROM SMART WATCH
ONESEC:	EQU	28	;ONE SECOND DELAY USING SMARTWATCH
RLSTEP:	EQU	29	;RELAY SEQUENCER
DELONE:	EQU	30	;ONE SECOND DELAY LOOP
SCANKEY: EQU	31	;SCAN THE KEYBOARD
INTELH:	EQU	32	;RECEIVE INTEL HEX FILE
SPLIT:	EQU	33	;SEPARATE A BYTE INTO NYBBLES
SNDMSG:	EQU	34	;SND ZERO TERMINATED STRING TO SERIAL PORT
BITASC:	EQU	35	;CONVERT A BYTE INTO AN ASCII STRING OF ONES AND ZEROES
WRDASC:	EQU	36	;CONVERT A WORD TO ASCII
BYTASC:	EQU	37	;CONVERT A BYTE TO ASCII
NYBASC:	EQU	38	;CONVERT A NYBBLE TO ASCII
PCBTYP:	EQU	39	;RETURNS BOARD TYPE, SC OR TEC-1F
PRNTSZ:	EQU	40	;INLINE SERIAL PRINT STRING
KBDTYP:	EQU	41	;RETURNS KEYBOARD TYPE
UPDATE:	EQU	42  ;UPDATE DISPLAY AND MODE DECIMAL POINT SEGMENTS
VARRAM:	EQU	43	;RETURN BASE VARIABLE ADDRESS
SERINI:	EQU	44	;INITIALISE BIT BANG SERIAL PORT
SCBUG:	EQU	45	;SCBUG SERIAL MONITOR

;END OF PARTIAL INCLUDE FILE
    END
