; STOPWATCH PROGRAM FOR SOUTHERN CROSS COMPUTER (Z80)
; VERSION FOR SCNEO ROM WITH SERIAL MODULE

; V 1.0 -- USING AZ80 ASSEMBLER

; TO ASSEMBLE:  ./az80 StopWatchSerialV1.asm -l StopWatchSerialV1.lst
;               -o StopWatchSerialV1.hex (all on one command)

; + ON THE KEYPAD STARTS THE TIMER.  - WILL PAUSE THE TIMER.
; 0 ON THE KEYPAD RESETS THE TIMER.

; -- RICKY BRYCE


    ORG 2000H       ; ON SOUTHERN CROSS, WE START AT 2000H
    
; DEFINE PRESETS FOR DELAY LOOP
; TO INCREMENT EVERY SECOND (TRIAL AND ERROR)

; ** BEGIN HEAD **
; THESE SETTINGS WILL COARSE ADJUST CLOCK CALIBRATION
; FOR FINER TUNING USE NOPS IN DELAY LOOP
DELAYLOW: EQU 49H	    ; 47H  50H IS TOO SLOW  47 TOO FAST
DELAYHIGH: EQU 00H; 	; DELAY HIGH BYTE START 01H WAS 0
; ** END HEAD **

; ** BEGIN INTRO **
INTRO:
    LD B,0FFH       ; START B AT $FF
    LD HL,0002H     ; TONE DURATION
INTLOOP:
    LD A,3FH        ; SET A FOR 6 DISPLAYS AT ONCE
    OUT (85H),A     ; THEN TURN THEM ON
    LD A,B          ; LOAD LOOP VALUE TO A
    OUT (84H),A     ; SEND THIS TO THE DISPLAYS
    LD C,TONE       ; THEN SOUND A TONE FOR THIS VALUE
    RST SYSTEM
    DJNZ INTLOOP
; ** END INTRO **

; ** BEGIN INITIALIZE **    
INIT: ; INITIALIZE REGISTERS AND MEMORY
    LD A,0  ; ZERO ACCUMULATOR
    LD DE,0 ; NOT USED HERE (CAN HOLD 16 BIT ADDRESSES)
    LD HL,0 ; 16 BIT REGISTER (FOR MEMORY ADDRESSES)
    LD BC,0 ; USED FOR DELAYS
    
    LD IX,DELAYTIME     ; IX AND IY ARE INDEX REGISTERS
    LD (IX+0),DELAYLOW  ; HIGH BYTE DELAY LOOP
    LD (IX+1),DELAYHIGH ; LOW BYTE DELAY LOOP

; SET UP INDEX REGISTERS
    LD IX,HUNDREDTHS
    LD IY,MESSAGE

    ; CLEAR WORKSPACE
    LD A,0              ; ZERO THE A REGISTER
    LD HL,HUNDREDTH     ; IX AND IY ARE INDEX REGISTERS
    LD B,5
CLRWRK:
    LD (HL),A         ; ZERO WORKSPACE
    INC HL
    DJNZ CLRWRK

    ; INITIALIZE MESSAGE
    LD A,0
    LD HL, MESSAGE
    LD B, 7
CLRMSG:
    LD (HL),A
    INC HL
    DJNZ CLRMSG

    ; SET UP BACKSPACES
    LD A,8
    LD HL,MESSAGE+8
    LD B,8 ; BACKSPACES + 1
BACKSPC:
    LD (HL),A
    INC HL
    DJNZ BACKSPC

    LD A,00H
    LD (MESSAGE+16),A      ; ZERO TO TERMINATE THE MESSAGE
    LD (MESSAGE+17),A      ; SPARE


    LD A,02H		; MODES: 1=RUN, 2=STOP, 3=RESET
    LD (WTMODE),A	; SAVE MODE 2 TO MEMORY
    LD A,00H		; LOAD A WITH 0H
    LD (RSTREQ),A	; BE SURE RESET REQUEST IS KILLED
; ** END INITIALIZE **    
   
; ** BEGIN MAIN ROUTINE **
BEGIN:
    CALL SCANDS
    CALL DELAY		; DELAY TO CALIBRATE FOR SECONDS

HUNDREDTHS:
    LD A,(IX+0)	        ; LOAD ACCUMULATOR WITH HUNDREDTHS
    INC A		        ; INCREMENT LOWER BYTE
    CP 0AH              ; CHECK FOR 0A
    JR Z,TENTHS         ; IF A, THEN GO TO TENTHS
    LD A,(IX+0)         ; OTHERWISE RELOAD A
    INC A               ; INCREMENT A
    LD (IX+0),A	        ; STORE A TO MEMORY
    JP BEGIN            ; THEN GO BACK TO BEGIN

TENTHS:                 ; TIME TO INCREMENT 10THS
    LD A,0              ; LOAD 0 TO A
    LD (IX+0),A         ; PLACE 0 IN HUNDREDTHS PLACE
    LD A,(IX+1)         ; LOAD TENTHS PLACE
    INC A               ; INCREMENT THENTHS PLACE
    CP 0AH              ; SEE IF IT'S REACHED A
    JR Z,ONES           ; IF SO, THEN JUMP TO ONES
    LD A,(IX+1)         ; LOAD TENTHS
    INC A               ; INCREMENT TENTHS
    LD (IX+1),A         ; STORE TENTHS
    JP BEGIN            ; START OVER

ONES:                   ; TIME TO INCREMENT ONES
    LD A,0              ; LOAD 0 TO ACCUMULATOR
    LD (IX+1),A         ; SET TENTHS TO 0
    LD A,(IX+2)         ; LOAD ONES
    INC A               ; INCREMENT ONES
    CP 0AH              ; COMPARE AGAINST A
    JR Z,TENS           ; IF SO, THEN GO TO TENS
    LD A,(IX+2)         ; RELOAD ONES
    INC A               ; INCREMENT ONES
    LD (IX+2),A         ; STORE ONES
    JP BEGIN            ; START AGAIN

TENS:                   ; TIME TO INCREMENT TENS
    LD A,0              ; LOAD A WITH 0
    LD (IX+2),A         ; STORE 0 TO ONES
    LD A,(IX+3)         ; LOAD TENS
    INC A               ; INCREMENT TENS
    CP 06H              ; SEE IF IT'S REACHED A
    JR Z,MINONES        ; IF SO, THEN GO TO MINUTE ONES
    LD A,(IX+3)         ; RELOAD TENS
    INC A               ; INCREMENT TENS
    LD (IX+3),A         ; STORE TENS
    JP BEGIN            ; START OVER

MINONES:
    LD A,0              ; LOAD A WITH 0
    LD (IX+3),A         ; STORE TO TENS
    LD A,(IX+4)         ; LOAD MINUTE ONES
    INC A               ; INCREMENT MINUTE ONES
    CP 0AH              ; SEE IF IT'S REACHED A
    JR Z,MINTENS        ; IF SO, THEN GO TO MINUTE TENS
    LD A,(IX+4)         ; RELOAD MINUTE ONES
    INC A               ; INCREMENT MINUTE ONES
    LD (IX+4),A         ; STORE MINUTE ONES
    JP BEGIN            ; START OVER

MINTENS:
    LD A,0              ; LOAD ACCUMULATOR WITH 0
    LD (IX+4),A         ; STORE ZERO TO MINUTE ONES
    LD A,(IX+5)         ; LOAD MINUTE TENS
    INC A               ; INCREMENT MINUTE TENS
    CP 0AH              ; COMPARE TO A
    JR Z,ZEROALL        ; IF SO, THEN RESET EVERYTHING TO ZERO
    LD A,(IX+5)         ; RELOAD MINUTE TENS
    INC A               ; INCREMENT MINUTE TENS
    LD (IX+5),A         ; STORE MINUTE TENS
    JP BEGIN            ; START OVER

ZEROALL:                ; ZERO EVERYTHING
    LD A,0              ; LOAD 0 TO A
    LD (IX+0),A         ; ZERO HUNDREDTHS
    LD (IX+1),A         ; ZERO TENTHS
    LD (IX+2),A         ; ZERO ONES
    LD (IX+3),A         ; ZERO TENS
    LD (IX+4),A         ; ZERO HUNDREDS
    LD (IX+5),A         ; ZERO THOUSANDS
    JP BEGIN            ; START OVER
    
; ** END MAIN ROUTINE **

; ** BEGIN CHECK MDOE SUBROUTINE **
MODECHK:  ; MODE 1 = RUN; MODE 2 = STOP (HOLD) ; MODE 3 = RESET
MODE3:
    LD A,(WTMODE)	; LOAD MODE TO A
    CP 03H		    ; IF MODE IS 3, WE NEED TO RESET
    JP NZ,MODE2		; IF NOT 3 CHECK FOR MODE 2
    LD A,02H		; LOAD 02H TO THE ACCUMULATOR
    LD (WTMODE),A	; SET THE MODE TO HALT (02H)
    LD A,01H		; LOAD 01H TO ACCUMULATOR
    LD (RSTREQ),A	; NO REASON TO DELAY IF RESETTING
    LD A,00H		; LOAD 00H TO ACCUMULATOR

MODE2:
    CALL CHECKKEY	; CHECK FOR KEYPAD INPUT
    ;CALL SCANDS		; SCAN THE DISPLAY
    LD A,(WTMODE)	; RELOAD A WITH MODE
    CP 02H		    ; IF MODE IS 2, WE NEED TO HOLD
    JP Z, MODE2		; HOLD IN LOOP
    JP MODERET		; IF MODE CHANGED, WE CAN RETURN

MODE1:			    ; IF MODE IS 1, WE DON'T NEED TO DO ANYTHING

MODERET:
    RET
; ** END CHECK MODE SUBROUTINE **
    
; ** BEGIN SCAN DISPLAY ROUTINE **    
SCANDS:			    ; BUILD MESSAGE, AND SEND TO TERMINAL
    LD IX,HUNDREDTH ; SET UP IX STARTING AT HUNDREDTHS
    LD IY,MESSAGE   ; SET UP IY WITH MESSAGE ADDERSS
    LD A, (IX+5)    ; HUNDREDTHS
    ADD A,30H       ; CONVERT TO ASCII
    LD (IY+0), A    ; STORE TO MESSAGE
    LD A, (IX+4)    ; TENTHS
    ADD A,30H       ; CONVERT TO ASCII
    LD (IY+1), A    ; STORE TO MESSAGE
    LD A, (IX+3)    ; ONES
    ADD A,30H       ; CONVERT TO ASCII
    LD (IY+3), A    ; STORE TO MESSAGE
    LD A, (IX+2)    ; TENS
    ADD A,30H       ; CONVERT TO ASCII
    LD (IY+4), A    ; STORE TO MESSAGE
    LD A, (IX+1)    ; MINUTE ONES
    ADD A,30H       ; CONVERT TO ASCII
    LD (IY+6), A    ; STORE TO MESSAGE
    LD A, (IX+0)    ; MINUTE TENS
    ADD A,30H       ; CONVERT TO ASCII
    LD (IY+7), A    ; STORE TO MESSAGE
    ld (IY+2), 3AH  ; ADD COLON AFTER MINUTES
    LD (IY+5), 3AH  ; ADD COLON AFTER SECONDS
    LD HL,MESSAGE   ; SETUP UP HL WITH MESSAGE ADDRESS
    LD C,SNDMSG     ; FUNCTION CALL TO SEND THE MESSAGE
    RST SYSTEM      ; CALL THE SYSTEM


; ** END SCAN DISPLAY ROUTINE **

; ** BEGIN CHECKKEY ROUTINE TO SEE IF A KEY IS PRESSED **
CHECKKEY:
    IN A,(86H)	    	; INPUT FROM KEYPAD AT PORT $86
    BIT 5,A             ; CHECK STATUS BIT OF KEYPAD
    JP NZ,CHECKKEYCNT1  ; IF KEY PRESSED JUMP OVER RETURN
    LD A,00H		    ; LOAD 0H TO ACCUMULATOR
    LD (KEYONS),A 	    ; CLEAR ONE SHOT BIT IF NO KEY PRESSED
    JP CHECKKEYRET      ; IF NO KEY PRESSED, THEN WE RETURN
CHECKKEYCNT1:
    ; AT THIS POINT, WE KNOW A KEY WAS PRESSED
    AND 1FH             ; GET RID OF THE UPPER 3 BITS
    LD (KEYVALUE),A     ; STORE THE KEY PRESSED TO KEYVALUE
    LD A,(KEYONS)	    ; LOAD A WITH ONE SHOT VALUE
    OR A                ; CHECK TO SEE IF IT'S CLEARED
    JP NZ,CHECKKEYRET   ; KEY IS STILL PRESSED FROM BEFORE
    LD A,(KEYVALUE)     ; RESTORE A WITH KEY VALUE
    CP 12H              ; CHECK FOR +
    JP NZ,NOT12H	    ; IF NOT 12H, CHECK FOR 13H
    CALL HIGHTONE       ; SOUND HIGH TONE
    LD A,01H		    ; LOAD 01H TO ACCUMULATOR
    LD (WTMODE),A	    ; SET MODE TO RUN
    LD (KEYONS),A	    ; SET ONE SHOT VALUE HIGH
    JP CHECKKEYRET      ; RETURN FROM SUBROUTINE
NOT12H:
    LD A,(KEYVALUE)     ; RELOAD KEY VALUE INTO A
    CP 13H              ; CHECK FOR -
    JP NZ,NOT13H	    ; IF NOT 13, CHECK FOR 0        
    CALL LOWTONE        ; SOUND LOW TONE
    LD A,02H		    ; LOAD 02H TO ACCUMULATOR
    LD (WTMODE),A  	    ; ENTER HOLD MODE
    LD A,01H		    ; LOAD 01H TO ACCUMULATOR
    LD (KEYONS),A	    ; SET ONE SHOT VALUE HIGH
    JP CHECKKEYRET      ; RETURN FROM SUBROUTINE
NOT13H:
    LD A,(KEYVALUE)	    ; RELOAD KEYVALUE MEMORY TO A
    OR A                ; COMPARE A TO 0
    JP NZ,NOKEY         ; KEY PRESSED IS INVALID
    LD A,03H		    ; LOAD 03H TO ACCUMULATOR MODE=3
    LD (WTMODE),A	    ; ENTER RESET MODE
    JP WAITKEYRL        ; TIMER PAUSES WHILE PRESSED
    
NOKEY:                  ; KEYPRESS IS INVALID
    RST BREAK           ; TROUBLESHOOTING
    JP CHECKKEYRET      ; RETURN FROM SUBROUTINE
    
WAITKEYRL:
    LD C, SKEYRL        ; WAIT FOR KEY RELEASE
    RST SYSTEM

CHECKKEYRET:
    RET     ; RETURN TO NEXT INSTRUCTION AFTER THIS CALL
; ** END CHECKKEY ROUTINE TO SEE IF A KEY IS PRESSED **

; ** BEGIN DELAY ROUTINE
DELAY:			; DELAY ROUTINE USING BC PAIR
    LD BC,(DELAYTIME)	; SET BC TO DELAYTIME
DELAY1:
    DEC BC		        ; DECREMENT BC PAIR
    LD A,00H		    ; LOAD ACCUMULATOR WITH ZERO
    LD (RSTREQ),A	    ; CLEAR KILLDELAY REQUEST

    PUSH BC		        ; BC USED BY SUBROUTINES -- BACK IT UP
    CALL CHECKKEY	    ; CHECK TO SEE IF A KEY IS PRESSED
    CALL MODECHK	    ; CHECK TIMER MODE
    POP BC		        ; RESTORE BC BEFORE GOING ANYWHERE ELSE

    LD A,(RSTREQ)  	    ; CHECK TO SEE IF WE NEED DELAY
    OR A              	; SEE IF IT'S OK TO CONTINUE DELAY
    JP Z, CONTDLY1    	; IF SO, CONTINUE
    JP DELAYRET       	; OTHERWISE, RETURN
CONTDLY1:
    LD A,B		; LOAD A WITH HIGH BYTE OF DLY SECOND
    OR C		; OR WITH C - CHECK FOR ANY HIGH BITS
    
    ; NOPS FOR TIME CALIBRATION
    NOP
    NOP 
    NOP
    NOP 
    NOP 
    NOP ; TOO FAST

    NOP
    NOP
    NOP
    NOP
    NOP
    NOP  ; LITTLE BIT TOO FAST

    NOP ;  1/4 SEC EVERY MINUTE FAST

    JP NZ,DELAY1	; RE-RUN LOOP
        

DELAYRET:
    PUSH BC
    LD B,07H
FINEDELAY:
    NOP
    DJNZ FINEDELAY
    POP BC

    RET ; ALL DONE WITH DELAY ROUTINE
; ** END DELAY ROUTINE **   

; ** BEGIN HIGH TONE **
HIGHTONE:
	LD HL,0075H	; TONE DURATION
	LD A,25H	; TONE PITCH
	LD C,TONE	; LOAD C WITH TONE FUNCTION CODE
	RST SYSTEM	; CALL SYSTEM
	LD A,15H	; TONE PITCH
	LD C,TONE	; LOAD C WITH TONE FUNCTION CODE
	RST SYSTEM	; CALL SYSTEM
	RET
; ** END HIGH TONE **

; ** BEGIN LOW TONE **
LOWTONE:
	LD HL,0025H	; TONE DURATION
	LD A,55H	; TONE PITCH
	LD C,TONE	; TONE FUNCTION CODE
	RST SYSTEM	; CALL SYSTEM
	LD A,75H	; TONE PITCH
	LD C,TONE	; TONE FUNCTION CODE
	RST SYSTEM	; CALL SYSTEM
	RET
; ** END LOW TONE **

; ** BEGIN CLICKTONE **
CLKTONE:    
	LD HL,0015H	; TONE DURATION
	LD A,99H	; TONE PITCH
	LD C,TONE	; TONE FUNCTION CODE
	RST SYSTEM	; CALL SYSTEM
	RET
; ** END CLICKTONE

; ** BEGIN FOOTER (DEFINE BYTES (DB)) **
    ORG 2300H		; AVOID CROSSING PAGE BOUNDARY
    
; ** BEGIN DATA TABLES (ARRAYS) **
DELAYTIME: 		; FOR DELAY LOOPS
    DB 0FFH,0FFH 	; THESE WILL BE OVERWRITTEN WITH 
				    ;CONSTANTS DEFINED IN HEADER
    
MESSAGE: ; DIGITS TO DISPLAY
    DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H    ; MESSAGE TO DISPLAY

HUNDREDTH:  ; WORKSPACE STARTING AT HUNDREDTHS
    DB 00H, 00H, 00H, 00H, 00H, 00H
                       
KEYVALUE:           ; STORE KEY VALUE
    DB 00H
WTMODE:			    ; MEMORY LOCATION FOR STOPWATCH MODE
    DB 00H
KEYONS:			    ; MEMORY LOCATION FOR ONE SHOT
    DB 00H
RSTREQ:			    ; MEMORY FLAG FOR RESET REQUEST
    DB 00H
; ** END DATA TABLES (ARRAYS) **  

; ** END FOOTER (DEFINE BYTES (DB)) **

; CREATE LABEL (ALIAS) NAMED SYSTEM FOR MONITOR ENTRY POINT
SYSTEM: EQU 30H
BREAK:  EQU 38H

   
; Pasted some code out of the monitor definitions file.
; This is not the whole file.
; to obtain the file, visit:
; https://github.com/crsjones/Southern-Cross-Computer-z80/tree/main/SouthernCrossSBC_Monitor/SCMonitorV18
;--------------------------------------------
; S O U T H E R N   C R O S S   M O N I T O R
;--------------------------------------------
;
;  MONITOR DEFINITIONS FILE 
;  Version 1.8
;
; WRITTEN BY CRAIG R. S. JONES
; MELBOURNE, AUSTRALIA.
;
;--------------------
; SYSTEM CALL NUMBERS
;--------------------
;
;  LD   C,SYSTEM CALL NUMBER
;  RST  30H
;

MAIN:	EQU	0	;RESTART MONITOR
VERS:	EQU	1	;RETURNS MONITOR VERSION
DISADD:	EQU	2	;ADDRESS -> DISPLAY BUFFER
DISBYT:	EQU	3	;DATA -> DISPLAY BUFFER
CLRBUF:	EQU	4	;CLEAR DISPLAY BUFFER
SCAND:  EQU	5	;SCAN DISPLAY
CONBYT:	EQU	6	;BYTE -> DISPLAY CODE
CONVHI:	EQU	7	;HI NYBBLE -> DISPLAY CODE
CONVLO:	EQU	8	;LO NYBBLE - > DISPLAY CODE
SKEYIN:	EQU	9	;SCAN DISPLAY UNTIL KEY PRESS
SKEYRL:	EQU	10	;SCAN DISPLAY UNTIL KEY RELEASE
KEYIN:	EQU	11	;WAIT FOR KEY PRESS
KEYREL:	EQU	12	;WAIT FOR KEY RELEASE
MENU:	EQU	13	;SELECT ENTRY FROM MENU
CHKSUM:	EQU	14	;CALCULATE CHECKSUM
MUL16:	EQU	15	;16 BIT MULTIPLY
RAND:	EQU	16	;GENERATE RANDOM NUMBER
INDEXB:	EQU	17	;INDEX INTO BYTE TABLE
INDEXW:	EQU	18	;INDEX INTO WORD TABLE
MUSIC:	EQU	19	;PLAY MUSIC TABLE
TONE:	EQU	20	;PLAY A NOTE
BEEP:	EQU	21	;KEY ENTRY BEEP
SKATE:	EQU	22	;SCAN 8X8 DISPLAY
TXDATA:	EQU	23	;TRANSMIT SERIAL BYTE
RXDATA:	EQU	24	;RECEIVE SERIAL BYTE
ASCHEX:	EQU	25	;ASCII CODE -> HEX
WWATCH:	EQU	26	;WRITE TO SMART WATCH
RWATCH:	EQU	27	;READ FROM SMART WATCH
ONESEC:	EQU	28	;ONE SECOND DELAY USING SMARTWATCH
RLSTEP:	EQU	29	;RELAY SEQUENCER
DELONE:	EQU	30	;ONE SECOND DELAY LOOP
SCANKEY: EQU	31	;SCAN THE KEYBOARD
INTELH:	EQU	32	;RECEIVE INTEL HEX FILE
SPLIT:	EQU	33	;SEPARATE A BYTE INTO NYBBLES
SNDMSG:	EQU	34	;SND ZERO TERMINATED STRING TO SERIAL PORT
BITASC:	EQU	35	;CONVERT A BYTE INTO AN ASCII STRING OF ONES AND ZEROES
WRDASC:	EQU	36	;CONVERT A WORD TO ASCII
BYTASC:	EQU	37	;CONVERT A BYTE TO ASCII
NYBASC:	EQU	38	;CONVERT A NYBBLE TO ASCII
PCBTYP:	EQU	39	;RETURNS BOARD TYPE, SC OR TEC-1F
PRNTSZ:	EQU	40	;INLINE SERIAL PRINT STRING
KBDTYP:	EQU	41	;RETURNS KEYBOARD TYPE
UPDATE:	EQU	42  ;UPDATE DISPLAY AND MODE DECIMAL POINT SEGMENTS
VARRAM:	EQU	43	;RETURN BASE VARIABLE ADDRESS
SERINI:	EQU	44	;INITIALISE BIT BANG SERIAL PORT
SCBUG:	EQU	45	;SCBUG SERIAL MONITOR

;END OF PARTIAL INCLUDE FILE
    END
